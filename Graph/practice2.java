import java.util.*;

public class practice2 {
    static class Edge {
        int src;
        int dest;
        int wt;

        public Edge(int s, int d, int w) {
            this.src = s;
            this.dest = d;
            this.wt = w;
        }
    }

    public static void createGraph(ArrayList<Edge>[] graph) {
        for (int i = 0; i < graph.length; i++) {
            graph[i] = new ArrayList<>();
        }

        graph[0].add(new Edge(0, 1, 1));
        graph[0].add(new Edge(0, 2, 1));

        graph[1].add(new Edge(1, 0, 1));
        graph[1].add(new Edge(1, 3, 1));

        graph[2].add(new Edge(2, 0, 1));
        graph[2].add(new Edge(2, 4, 1));

        graph[3].add(new Edge(3, 1, 1));
        graph[3].add(new Edge(3, 4, 1));
        graph[3].add(new Edge(3, 5, 1));

        graph[4].add(new Edge(4, 2, 1));
        graph[4].add(new Edge(4, 3, 1));
        graph[4].add(new Edge(4, 5, 1));

        graph[5].add(new Edge(5, 3, 1));
        graph[5].add(new Edge(5, 4, 1));
        graph[5].add(new Edge(5, 6, 1));

        graph[6].add(new Edge(6, 5, 1));
    }

/* In your current implementation, the vis array is being created and initialized 
at the beginning of each recursive call to dfs, which causes the visited nodes 
 to be forgotten during the recursion. To fix this issue, you need to ensure that the vis array 
 is shared among recursive calls and properly updated. One way to address this is by passing 
 the vis array as an argument to the dfs method */

 
    public static void dfs(ArrayList<Edge>[] graph, int curr, boolean vis[]) {
        // boolean vis[] = new boolean[graph.length];
        System.out.print(curr+" ");
        vis[curr] = true;

        for(int i=0; i<graph[curr   ].size();i++){
            Edge e = graph[curr].get(i);
            if(!vis[e.dest]){
                dfs(graph, e.dest, vis);
            }
        }
    }

    public static void main(String[] args) {
        int V = 7;
        ArrayList<Edge>[] graph = new ArrayList[V];
        createGraph(graph);
        // bfs(graph);
        dfs(graph, 0, new boolean[V]);

    }
}
